---
layout: post
title: "java杂笔"
date:   2021-05-01
tags: [java]
comments: true
author: forge1yc 
---

# 设计模式
设计模式中的代理和装饰器主要区别：
* 代理不增加别的功能，只是优化了内部处理
* 装饰器增加了别的功能，需要一个大的类来包含这个装饰器，这样总的功能就丰富了


# 同步与竞争
以前我对java中或者说所有语言中的锁和同步问题有很多模糊的地方，比如我不知道什么时候该用锁，什么时候该用通知：notify
wait 这种操作，今天又一次浏览博客的时候好像理解了一点：

## 锁的目的是啥？
首先我们要明白一个问题，锁的出现是为了解决什么问题的，我之前理解是为了解决同步问题，大错特错，这就是理解不到位，锁的出现是为了
解决竞争的问题，因为多个线程想做同一件事情，只能让一个线程去做，同时做这件事情就有问题，比如存钱。

那么锁解决了竞争的问题，在并发编程中还有啥问题需要解决呢，我们可以想一下多个线程如果想要做一件事情的不同部分，举个例子，在最常见的
生产者消费者模型中，如果多个线程同时写入（锁实现）,与此同时同个线程进行消费也就是取出的时候，虽然取出动作也可以看成多线程竞争，所以需要加锁，
这没问题。

但是生产者消费者模型是一个事情，我们加锁只解决了多个工人（线程）同时工作的问题，但是没有解决如何协调生产和消费的问题，比如没有货物的时候，消费者
一群工人应该怎么做，如果映射现实就是“等待”，这个等待的操作对应java里面就是this.wait()操作。

聪明的同学可能会问，如果我不等待（wait）只是一直取这个队列里面的内容，没有就返回空，不行吗？bingo！你说的很对，这一点问题没有，可是“工人也是人啊”，工人要一直查看
有没有货物到来，有没有货物到来，工人经历是有限的，工人这种不间断的查看是要耗费更多“粮食”（cpu计算资源)的，所以这里就提现了wait
的强大之处，我先wait住，然后等待放货物的工人给我打一个电话，说有货物到了（这里应该是给消费货物的工人集体广播，竞争才有效率嘛）

所以自然而然引申出生产工人的一个操作，this.notifyAll()
通知所有的工人（广播），这样一来就能够协同工作了，双方都节省了粮食和精力，岂不妙哉！！！（生产者是主动型的，所以不会说浪费粮食，毕竟有货物才干活）

总结：现在我们理解了锁是用来解决竞争问题，而wait 与  notify
是为了解决协作问题（当然你也可以理解成同步问题）这与go的协程是有区别的，协程是语言层面的调度合作，go也是通过chan
实现了这种协作关系，我个人认为go的更优雅，不用记住java中千奇百怪的名称。当然这是一家之言，自行评判！

# wait 和 notify + synchronized 真的就没问题了吗？
> 待续
